<html>
<h3>Student: Dario Platania(s230094) A.A. 2017/18</h3>
<body>
  <p>In my server implementation I created three files; I take care of the initial serialization in the NfvDeployer file. In the NfvResources file instead I expose the resources and recall the functions inside the Neo4JDB file.</p>
  <p>In the Neo4JDB file, as a first step, I start the serialization (Singleton) and then I expose the various GET and POST resources. I can request a whole set of NFFG, or a single NFFG.</p>
  <p>In these functions I always check the existence of the Nffg that is passed to me and if it exists it is returned to me. The same checks (on their consistency) are made when I get one or more nodes, and from the single node I can see what the reachablehosts are.</p>
  <p>As a post I implemented the post of an NFFG and check if it exists or not; if it already exists, not the load, otherwise I proceed to loading by checking if there are two equal nodes inside the NFFG one.</p>
  <p>For the POST of the nodes instead check if the nffg that is passed to me exists or not; check if the node already exists and if the host exists where I have to allocate it; if the host does not exist, I choose it randomly; I also do the various checks on the resources available in the hosts and allocate node if they are successful.</p>
  <p>In the link POST instead check if the nffg exists and if source and destination node exist; checked these fields I look for the links and I go to see if it exists or not; if the link does not exist load it, otherwise I'll go to see the overwrite flag is true or false; in the first case I overwrite the link in question, in the second I do not load it. I have also implemented the get of the catalog, the hosts and the performances.</p>
  <p>As structures I used ConcurrentHashMap which by definition give the possibility to multiple threads to read and write on it without the possibility of receiving expired or damaged data. ConcurrentHashMap provides its own synchronization, so there is no need to synchronize accesses explicitly.</p>
  <p>For synchronization I have also used the syncronized method on the whole NFFG object that allows me to have no problems of synchronization in reading and writing.</p>

</body>
